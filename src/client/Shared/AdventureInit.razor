@using c5m._2d6Dungeon;
@inject IJSRuntime JSRuntime 

<FluentLabel Typo="Typography.PageTitle">Adventure Initialization</FluentLabel>

<FluentLabel>To create a new adventure you will need: </FluentLabel>

<FluentStack Orientation="Orientation.Vertical">
    <FluentCard >
        @if (selectedAdventurer == null)
        {
            <AdventurerPicker @bind-ParentPlayer="selectedAdventurer"></AdventurerPicker>
        }
        else
        {
            <FluentPersona  Name="@(selectedAdventurer.Name)"
                            ImageSize="50px"
                            Status="PresenceStatus.Available"
                            StatusSize="PresenceBadgeSize.Small">
                    <FluentStack Orientation="Orientation.Vertical" VerticalGap="0">
                        <FluentLabel Typo="Typography.H3">@selectedAdventurer.Name</FluentLabel>
                        <FluentLabel Typo="Typography.Body"><b>XP:</b> @selectedAdventurer.XP.ToString()</FluentLabel>
                        <FluentLabel Typo="Typography.Body"><b>Level:</b> @selectedAdventurer.Level.ToString()</FluentLabel>
                    </FluentStack>
            </FluentPersona>
        }  
    </FluentCard> 

    <FluentCard >
        <h3>Create a new Dungeon</h3>

        <div class="row">
            <div class="col-md-12 text-right">
                    <p id="message"></p>
            </div>
            <div class="col-md-12 text-right">
                <button type="button" class="btn btn-outline-primary" @onclick=RollDices>@actionLabel</button>
            </div>
        </div>
        <div style="padding:20px;">
            @if(primaryDice != 0)
            {
                <img alt="@(primaryDice)" src="dices/dice@(primaryDice).jpg" />
            }
            @if(secondaryDice != 0)
            {
                <img alt="@(secondaryDice)" src="dices/purlple-dice@(secondaryDice).jpg" />
            }
        </div>

        <canvas id="dotCanvas" style="width: 800px; height: 800px; padding:10px;"></canvas> 
    </FluentCard>  
</FluentStack>
<div class="row">
    <div class="col-md-12 text-right">
        <FluentButton Appearance="Appearance.Accent" @onclick="Generate">Generate</FluentButton>
        <FluentButton Appearance="Appearance.Accent" @onclick="StarGame" disabled="@isStartDisable">Start</FluentButton>
    </div>
</div>

@code {

    [Parameter] public Adventure? ParentAdventure {get; set;}

    [Parameter] public EventCallback<Adventure> ParentAdventureChanged { get; set; }

    private Adventure? betaAdventure;
    public Game.Adventurer? selectedAdventurer;
    private bool isStartDisable = false;
    private bool firstRender = true;
    public int primaryDice = 0;
    public int secondaryDice = 0;
    private string actionLabel = "Roll 2D6 to determine the Entrance of the dungeon";
    private MappedRoom entryRoom;

    private void StarGame()
    {
        betaAdventure = new Adventure();
        betaAdventure.Adventurer = selectedAdventurer;

        

        betaAdventure.Dungeon.MappedRooms.Add(entryRoom);
        throw new NotImplementedException();
        //todo: save the adventure
    }

    private void Generate()
    {
        betaAdventure = new Adventure();
        isStartDisable = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender){
        //await JSRuntime.InvokeVoidAsync("resizeCanvas");
    }


    private async Task RollDices()
    {
        await RenderCanvas() ;
        var dResult = DiceResult.Roll2Dices();
        primaryDice = dResult.PrimaryDice;
        secondaryDice = dResult.SecondaryDice;
        entryRoom = Dungeon.StartDungeonLevel(dResult);

        //hardcoded temporary
        entryRoom.CoordX = 2;
        entryRoom.CoordY = 5;

        SetDungeonEntranceDoor(entryRoom);
        AssignExits(entryRoom, "S");
        await DrawRoom(entryRoom, true);
        
        actionLabel = "The lobby has 3 exits";
    }

    private async Task RenderCanvas() 
    { 
        if (firstRender) 
        { 
            firstRender = false;
            await JSRuntime.InvokeVoidAsync("onResize");
        } 
    }

    protected async Task DrawRoom(MappedRoom currentRoom, bool isLobby) 
    { 
        int gidX = (currentRoom.CoordX);
        int gidY = (currentRoom.CoordY);

        await JSRuntime.InvokeVoidAsync("DrawRoom",gidX, gidY, currentRoom.Width, currentRoom.Height);

        await DrawDoors(currentRoom, isLobby);
    }

    protected async Task DrawDoors(MappedRoom currentRoom, bool isLobby) 
    { 
        foreach(var door in currentRoom.Exits)
        {
            string orientation = GetDoorOrientation(door.onWall);
            int x = 0;
            int y = 0;
            bool isMain = false;

            switch(door.onWall)
            {
                case "N":
                    x = currentRoom.CoordX + door.PositionOnWall;
                    y = currentRoom.CoordY;
                    break;
                case "E":
                    x = currentRoom.CoordX + currentRoom.Width;
                    y = currentRoom.CoordY + door.PositionOnWall;
                    break;
                case "S":
                    x = currentRoom.CoordX + door.PositionOnWall;
                    y = currentRoom.CoordY + currentRoom.Height;
                    isMain = isLobby;
                    break;
                case "W":
                    x = currentRoom.CoordX;
                    y = currentRoom.CoordY + door.PositionOnWall;
                    break;
            }

            await JSRuntime.InvokeVoidAsync("DrawDoor",x, y, orientation, isMain);
        }

        
    }

    protected string GetDoorOrientation(string onWall)
    {
        if(onWall == "S" || onWall == "N")
        {
            return "H";
        }
        return "V";
    }

    protected void SetDungeonEntranceDoor(MappedRoom currentRoom)
    {
        var mainDoor = new Exit();
        mainDoor.onWall = "S";
        mainDoor.PositionOnWall = (int) Math.Ceiling( (double)currentRoom.Width/2 );
        mainDoor.Lockable = false;

        if(currentRoom.Exits == null)
            currentRoom.Exits = new List<Exit>();
        currentRoom.Exits.Add( mainDoor);
    }

    protected void AssignExits(MappedRoom currentRoom, string entrance)
    {
        Random rnd = new Random(currentRoom.Width * currentRoom.Height);
        var walls = new List<string>(){"N", "E", "S", "W"};
        walls.Remove(entrance);
        var wallsWithExits = walls.OrderBy(x => Guid.NewGuid()).Take<string>(currentRoom.ExitsCount);

        if(currentRoom.Exits == null)
                currentRoom.Exits = new List<Exit>();

        foreach(var wall in wallsWithExits)
        {
            var aDoor = new Exit();
            aDoor.onWall = wall;
            aDoor.PositionOnWall = rnd.Next(1, currentRoom.Height);
            aDoor.Lockable = false;
            
            currentRoom.Exits.Add(aDoor); 
        }
    }

}
