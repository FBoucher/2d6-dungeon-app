@using c5m._2d6Dungeon;
@inject IJSRuntime JSRuntime 

<h3>Adventure Initialization</h3>
<div>To create a new adventure you will need: </div>

<div class="jumbotron">
    @* <h3>Create or select an Adventurer</h3> *@
@if (selectedAdventurer == null)
{
    <AdventurerPicker @bind-ParentPlayer="selectedAdventurer"></AdventurerPicker>
}
else
{
    <div>
        <p><b>Name:</b> @selectedAdventurer.Name</p>
        <p><b>XP:</b> @selectedAdventurer.XP.ToString()</p>
        <p><b>Level:</b> @selectedAdventurer.Level.ToString()</p>
        <p><b>Copper Coins:</b> @selectedAdventurer.Coins.CupperCoins.ToString()</p>
    </div>
}  
</div> 

<div class="row">
    <h3>Create a new Dungeon</h3>

    <div class="row">
        <div class="col-md-12 text-right">
                <p id="message"></p>
        </div>
        <div class="col-md-12 text-right">
            <button type="button" class="btn btn-outline-primary" @onclick=RollDices>@actionLabel</button>
        </div>
    </div>
    <div style="padding:20px;">
        @if(primaryDice != 0)
        {
            <img alt="@(primaryDice)" src="dices/dice@(primaryDice).jpg" />
        }
        @if(secondaryDice != 0)
        {
            <img alt="@(secondaryDice)" src="dices/purlple-dice@(secondaryDice).jpg" />
        }
    </div>

    <canvas id="dotCanvas" style="width: 800px; height: 800px; padding:10px;"></canvas> 
</div>  

<div class="row">
    <div class="col-md-12 text-right">
        <button type="button" class="btn btn-outline-primary" @onclick="Generate">Generate</button>
        <button type="button" class="btn btn-outline-primary" @onclick="StarGame" disabled="@isStartDisable">Start</button>
    </div>
</div>



@code {

    [Parameter] public Adventure? ParentAdventure {get; set;}

    [Parameter] public EventCallback<Adventure> ParentAdventureChanged { get; set; }

    private Adventure? betaAdventure;
    public Game.Adventurer? selectedAdventurer;
    private bool isStartDisable = false;
    private bool firstRender = true;
    public int primaryDice = 0;
    public int secondaryDice = 0;
    private string actionLabel = "Roll 2D6 to determine the Entrance of the dungeon";
    private MappedRoom entryRoom;

    private void StarGame()
    {
        betaAdventure = new Adventure();
        betaAdventure.Adventurer = selectedAdventurer;

        

        betaAdventure.Dungeon.MappedRooms.Add(entryRoom);
        throw new NotImplementedException();
        //todo: save the adventure
    }

    private void Generate()
    {
        betaAdventure = new Adventure();
        isStartDisable = true;
    }

    private async Task RollDices()
    {
        await RenderCanvas() ;
        var dResult = DiceResult.Roll2Dices();
        primaryDice = dResult.PrimaryDice;
        secondaryDice = dResult.SecondaryDice;
        entryRoom = Dungeon.StartDungeonLevel(dResult);

        //hardcoded temporary
        entryRoom.CoordX = 2;
        entryRoom.CoordY = 5;

        SetDungeonEntranceDoor(entryRoom);
        AssignExits(entryRoom, "S");
        await DrawRoom(entryRoom, true);
        
        actionLabel = "The lobby has 3 exits";
    }

    private async Task RenderCanvas() 
    { 
        if (firstRender) 
        { 
            firstRender = false;
            await JSRuntime.InvokeVoidAsync("onResize");
        } 
    }

    protected async Task DrawRoom(MappedRoom currentRoom, bool isLobby) 
    { 
        int gidX = (currentRoom.CoordX);
        int gidY = (currentRoom.CoordY);

        await JSRuntime.InvokeVoidAsync("DrawRoom",gidX, gidY, currentRoom.Width, currentRoom.Height);

        await DrawDoors(currentRoom, isLobby);
    }

    protected async Task DrawDoors(MappedRoom currentRoom, bool isLobby) 
    { 
        foreach(var door in currentRoom.Exits)
        {
            string orientation = GetDoorOrientation(door.onWall);
            int x = 0;
            int y = 0;
            bool isMain = false;

            switch(door.onWall)
            {
                case "N":
                    x = currentRoom.CoordX + door.PositionOnWall;
                    y = currentRoom.CoordY;
                    break;
                case "E":
                    x = currentRoom.CoordX + currentRoom.Width;
                    y = currentRoom.CoordY + door.PositionOnWall;
                    break;
                case "S":
                    x = currentRoom.CoordX + door.PositionOnWall;
                    y = currentRoom.CoordY + currentRoom.Height;
                    isMain = isLobby;
                    break;
                case "W":
                    x = currentRoom.CoordX;
                    y = currentRoom.CoordY + door.PositionOnWall;
                    break;
            }

            await JSRuntime.InvokeVoidAsync("DrawDoor",x, y, orientation, isMain);
        }

        
    }

    protected string GetDoorOrientation(string onWall)
    {
        if(onWall == "S" || onWall == "N")
        {
            return "H";
        }
        return "V";
    }

    protected void SetDungeonEntranceDoor(MappedRoom currentRoom)
    {
        var mainDoor = new Exit();
        mainDoor.onWall = "S";
        mainDoor.PositionOnWall = (int) Math.Ceiling( (double)currentRoom.Width/2 );
        mainDoor.Lockable = false;

        if(currentRoom.Exits == null)
            currentRoom.Exits = new List<Exit>();
        currentRoom.Exits.Add( mainDoor);
    }

    protected void AssignExits(MappedRoom currentRoom, string entrance)
    {
        Random rnd = new Random(currentRoom.Width * currentRoom.Height);
        var walls = new List<string>(){"N", "E", "S", "W"};
        walls.Remove(entrance);
        var wallsWithExits = walls.OrderBy(x => Guid.NewGuid()).Take<string>(currentRoom.ExitsCount);

        if(currentRoom.Exits == null)
                currentRoom.Exits = new List<Exit>();

        foreach(var wall in wallsWithExits)
        {
            var aDoor = new Exit();
            aDoor.onWall = wall;
            aDoor.PositionOnWall = rnd.Next(1, currentRoom.Height);
            aDoor.Lockable = false;
            
            currentRoom.Exits.Add(aDoor); 
        }
    }

}
