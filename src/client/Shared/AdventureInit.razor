@using c5m._2d6Dungeon;
@inject IJSRuntime JSRuntime 
@inject ID6Service D6Service;

<FluentLabel Typo="Typography.PageTitle">Adventure Initialization</FluentLabel>

<FluentLabel>To create a new adventure you will need: </FluentLabel>

<FluentStack Orientation="Orientation.Vertical">
    <FluentCard >
        <FluentHeader>Select or Create an Adventurer</FluentHeader>
        @if (selectedAdventurer == null)
        {
            <AdventurerPicker @bind-ParentPlayer="selectedAdventurer"></AdventurerPicker>
        }
        else
        {
            <FluentPersona  Name="@(selectedAdventurer.Name)"
                            ImageSize="50px"
                            Status="PresenceStatus.Available"
                            StatusSize="PresenceBadgeSize.Small">
                    <FluentStack Orientation="Orientation.Vertical" VerticalGap="0">
                        <FluentLabel Typo="Typography.H3">@selectedAdventurer.Name</FluentLabel>
                        <FluentLabel Typo="Typography.Body"><b>XP:</b> @selectedAdventurer.XP.ToString()</FluentLabel>
                        <FluentLabel Typo="Typography.Body"><b>Level:</b> @selectedAdventurer.Level.ToString()</FluentLabel>
                    </FluentStack>
            </FluentPersona>
        }  
    </FluentCard> 

    <FluentCard >
        <FluentHeader>Create a new Dungeon</FluentHeader>
        <FluentStack Orientation="Orientation.Vertical">
            <p id="message"></p>
            <FluentButton @onclick=RollDices Appearance="Appearance.Accent" disabled="@(!isStartDisable)">@actionLabel</FluentButton>
        </FluentStack>
        <div style="padding:20px;">
            @if(primaryDice != 0)
            {
                <img alt="@(primaryDice)" src="dices/dice@(primaryDice).jpg" />
            }
            @if(secondaryDice != 0)
            {
                <img alt="@(secondaryDice)" src="dices/purlple-dice@(secondaryDice).jpg" />
            }
        </div>

        <canvas id="dotCanvas" style="width: 300px; height: 300px;" ></canvas> 
    </FluentCard>  
</FluentStack>


<FluentStack Orientation="Orientation.Horizontal">
        <FluentButton Appearance="Appearance.Accent" @onclick="StarGame" disabled="@isStartDisable">Start</FluentButton>
</FluentStack>

@code {

    [Parameter] public Adventure? ParentAdventure {get; set;}

    [Parameter] public EventCallback<Adventure> ParentAdventureChanged { get; set; }

    private Adventure? betaAdventure;
    public Game.Adventurer? selectedAdventurer;
    private bool isStartDisable = true;
    private bool firstRender = true;
    public int primaryDice = 0;
    public int secondaryDice = 0;
    private string actionLabel = "Roll 2D6 to determine the Entrance of the dungeon";
    private MappedRoom entryRoom;

    private async Task StarGame()
    {
        betaAdventure = new Adventure();
        betaAdventure.Adventurer = selectedAdventurer;
        betaAdventure.Dungeon.MappedRooms.Add(entryRoom);

        //todo: save the adventure
        betaAdventure = await D6Service.SaveNewAdventure(betaAdventure);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender){
        if (firstRender) 
        { 
            await JSRuntime.InvokeVoidAsync("onResize");
        } 
    }


    private async Task RollDices()
    {
        await RenderCanvas();
        var dResult = DiceResult.Roll2Dices();

        entryRoom = Dungeon.StartDungeonLevel(ref dResult);

        //TODO: hardcoded temporary
        entryRoom.CoordX = 1;
        entryRoom.CoordY = 2;

        SetDungeonEntranceDoor(entryRoom);
        AssignExits(entryRoom, "S");
        await DrawRoom(entryRoom, true);
        
        actionLabel = "Press the Start button to begin your adventure";
        isStartDisable = false;
    }

    private async Task RenderCanvas() 
    { 
        await JSRuntime.InvokeVoidAsync("onResize");
    }

    protected async Task DrawRoom(MappedRoom currentRoom, bool isLobby) 
    { 
        int gidX = (currentRoom.CoordX);
        int gidY = (currentRoom.CoordY);

        await JSRuntime.InvokeVoidAsync("DrawRoom",gidX, gidY, currentRoom.Width, currentRoom.Height);

        await DrawDoors(currentRoom, isLobby);
    }

    protected async Task DrawDoors(MappedRoom currentRoom, bool isLobby) 
    { 
        foreach(var door in currentRoom.Exits)
        {
            string orientation = GetDoorOrientation(door.onWall);
            int x = 0;
            int y = 0;
            bool isMain = false;

            switch(door.onWall)
            {
                case "N":
                    x = currentRoom.CoordX + door.PositionOnWall;
                    y = currentRoom.CoordY;
                    break;
                case "E":
                    x = currentRoom.CoordX + currentRoom.Width;
                    y = currentRoom.CoordY + door.PositionOnWall;
                    break;
                case "S":
                    x = currentRoom.CoordX + door.PositionOnWall;
                    y = currentRoom.CoordY + currentRoom.Height;
                    isMain = isLobby;
                    break;
                case "W":
                    x = currentRoom.CoordX;
                    y = currentRoom.CoordY + door.PositionOnWall;
                    break;
            }

            await JSRuntime.InvokeVoidAsync("DrawDoor",x, y, orientation, isMain);
        }

        
    }

    protected string GetDoorOrientation(string onWall)
    {
        if(onWall == "S" || onWall == "N")
        {
            return "H";
        }
        return "V";
    }

    protected void SetDungeonEntranceDoor(MappedRoom currentRoom)
    {
        var mainDoor = new Exit();
        mainDoor.onWall = "S";
        mainDoor.PositionOnWall = (int) Math.Ceiling( (double)currentRoom.Width/2 );
        mainDoor.Lockable = false;

        if(currentRoom.Exits == null)
            currentRoom.Exits = new List<Exit>();
        currentRoom.Exits.Add( mainDoor);
    }

    protected void AssignExits(MappedRoom currentRoom, string entrance)
    {
        int seed = DateTime.UtcNow.Millisecond;
        Random rnd = new Random(seed);
        
        var walls = new List<string>(){"N", "E", "S", "W"};
        walls.Remove(entrance);
        var wallsWithExits = walls.OrderBy(x => Guid.NewGuid()).Take<string>(currentRoom.ExitsCount);

        if(currentRoom.Exits == null)
                currentRoom.Exits = new List<Exit>();

        foreach(var wall in wallsWithExits)
        {
            var aDoor = new Exit();
            int maxPos = 0;
            aDoor.onWall = wall;
            if("EW".Contains(wall)){
                maxPos =  (currentRoom.Height +1);
            }
            else{
                maxPos =  (currentRoom.Width +1);
            }
            aDoor.PositionOnWall = rnd.Next(1, maxPos);
            aDoor.Lockable = false;
            currentRoom.Exits.Add(aDoor); 
        }
    }

}
